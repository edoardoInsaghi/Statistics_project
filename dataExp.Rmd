---
title: "dataExp"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r libraries}
library(dplyr)
library(tidyverse)
library(forcats)
library(infotheo)

library(ggplot2)
library(ggfortify)
library(ggcorrplot)
library(viridis)
library(patchwork)
color = "plasma" # choose between magma, inferno, plasma, viridis and i think there are others as well

library(umap)
library(caret)
```


```{r pre processing} 
df = read.csv("house-prices-advanced-regression-techniques/train.csv")
summary(df)

# NA
nas = colSums(is.na(df))
nas

# numerical var pre processing, some are commented out because log transforming does not
# really help with zero inflation
df$LotFrontage = ifelse(is.na(df$LotFrontage), mean(df$LotFrontage, na.rm=T), df$LotFrontage)
df$MasVnrArea = ifelse(is.na(df$MasVnrArea), mean(df$MasVnrArea, na.rm=T), df$MasVnrArea)
df$MasVnrArea = log(df$MasVnrArea + 1)
df$BsmtFinSF2 = log(df$BsmtFinSF2 + 1)
df$BsmtFinSF1 = log(df$BsmtFinSF1 + 1)
df$LotArea = log(df$LotArea + 1)
#df$LowQualFinSF = log(df$LowQualFinSF + 1)
#df$ScreenPorch = log(df$ScreenPorch + 1)
#df$X3SsnPorch = log(df$X3SsnPorch + 1)
#df$PoolArea = log(df$PoolArea + 1)
#df$MiscVal = log(df$MiscVal + 1)


# categorical variables, we have many variables with hundreds of unique values
# i am grouping together less frequent values; if there are few NA i am grouping
# them together with the new group, which will always be "other". i am excluding
# overly imbalanced variables (also debatable)
df = df %>%
  mutate(MSZoning = fct_lump(MSZoning, n = 2, other_level = "other"),
         LotShape = fct_lump(LotShape, n = 2, other_level = "other"),
         LandContour = fct_lump(LandContour, n = 3, other_level = "other"),
         LotConfig = fct_lump(LotConfig, n = 2, other_level = "other"),
         LandSlope = fct_lump(LandSlope, n = 2, other_level = "other"),
         Neighborhood = fct_lump(Neighborhood, n = 5, other_level = "other"),
         Condition1 = fct_lump(Condition1, n = 2, other_level = "other"),
         BldgType = fct_lump(BldgType, n = 2, other_level = "other"),
         HouseStyle = fct_lump(HouseStyle, n = 4, other_level = "other"),
         RoofStyle = fct_lump(RoofStyle, n = 2, other_level = "other"),
         Exterior1st = fct_lump(Exterior1st, n = 4, other_level = "other"),
         Exterior2nd = fct_lump(Exterior2nd, n = 4, other_level = "other"),
         MasVnrType = fct_lump(MasVnrType, n = 4, other_level = "other"),
         MasVnrType = fct_explicit_na(MasVnrType, na_level = "other"), # otherwise NA do weird stuff
         ExterQual = fct_lump(ExterQual, n = 4, other_level = "other"),
         ExterCond = fct_lump(ExterCond, n = 2, other_level = "other"),
         Foundation = fct_lump(Foundation, n = 2, other_level = "other"),
         BsmtQual = fct_lump(BsmtQual, n = 3, other_level = "other"),
         BsmtCond = fct_lump(BsmtCond, n = 2, other_level = "other"),
         BsmtExposure = fct_lump(BsmtExposure, n = 2, other_level = "other"),
         BsmtFinType1 = fct_lump(BsmtFinType1, n = 3, other_level = "other"),
         BsmtFinType2 = fct_lump(BsmtFinType2, n = 2, other_level = "other"),
         HeatingQC = fct_lump(HeatingQC, n = 3, other_level = "other"),
         Electrical = fct_lump(Electrical, n = 2, other_level = "other"),
         KitchenQual = fct_lump(KitchenQual, n = 3, other_level = "other"),
         Functional = fct_lump(Functional, n = 2, other_level = "other"),
         FireplaceQu = ifelse(Fireplaces == 0, as.character(0), as.character(FireplaceQu)),
         FireplaceQu = fct_lump(FireplaceQu, n = 3, other_level = "other"),
         GarageType = fct_lump(GarageType, n = 2, other_level = "other"),
         GarageFinish = fct_lump(GarageFinish, n = 3, other_level = "other"),
         GarageFinish = fct_explicit_na(GarageFinish, na_level = "other"), # otherwise NA do weird stuff
         PavedDrive = fct_lump(PavedDrive, n = 2, other_level = "other"),
         Electrical = fct_lump(Electrical, n = 2, other_level = "other"),
         SaleType = fct_lump(SaleType, n = 3, other_level = "other"),
         SaleCondition = fct_lump(SaleCondition, n = 2, other_level = "other")
         )

df[] = lapply(df, function(x) {
  if (is.factor(x) || is.character(x)) {
    x[is.na(x)] = "other"
  }
  return(x)
})



# Removing very imbalanced covariates and also some values full of NA 
exclude = c("Id", "Street", "Utilities", "Condition2", "RoofMatl", 
            "Heating", "GarageQual", "GarageCond")
excludeNA = c("GarageYrBlt", "Alley", "Fence", "PoolQC", "MiscFeature")
df = df %>% select(-one_of(c(exclude, excludeNA)))


# check everything works
#summary(df)
nas = colSums(is.na(df))
#nas
total_na = sum(is.na(df)) # no more NAs
```

```{r numerical variables}

# distribution of response variable
h = ggplot(data=df, aes(x=SalePrice)) +
  geom_histogram(fill="indianred", bins=30, color="black", aes(y = ..count..)) +
  scale_fill_identity() + theme_bw()
h


numdf = df %>% select_if(is.numeric)

# correlation matrix
c = ggcorrplot(cor(numdf)) + labs(title="Correlation Matrix")
c

# messy, many of these variables are probably still categorical
# also this plot is ugly, we won't show it
p = numdf %>% pivot_longer(names_to="variable", values_to="value", cols=everything()) %>% 
  ggplot(aes(x=value)) + geom_histogram(fill="indianred", bins=30, color="black", aes(y = ..count..)) + 
  theme_bw() + facet_wrap(~variable, scales="free") +
  labs(title="Histogram of the numerical variables")
p
```

```{r dimensionality reduction}

ndim = 4 # the dimension of the space onto which the data is projected
# both pca and UMAP, could be different between them

# these transformation are here only to make the gradient in the plots more visible
scaledSalePrice = (numdf$SalePrice - mean(numdf$SalePrice)) / sd(numdf$SalePrice) # i think this is useless
scaledSalePrice = log(numdf$SalePrice)
#scaledSalePrice = numdf$SalePrice
#low = quantile(numdf$SalePrice, 0.1)
#high = quantile(numdf$SalePrice, 0.9)

# naive attempt with pca
# I think we need to exclude the variable we wish to predict here, debatable tbf
pca = prcomp(numdf %>% select(-SalePrice), scale.=TRUE)

# elbowplot
r2 = pca$sdev^2 / sum(pca$sdev^2)
elbow_plot = data.frame("PC"=seq_along(r2), "ExplainedVar"=r2) %>% 
  ggplot(aes(x=PC, y=ExplainedVar)) + geom_line() + geom_point() + 
  labs(title="% of the variance explained by the PCs") + theme_bw()
# not ideal, we would like to see the first components to
#account for a bigger proportion of the variance
elbow_plot

# plots of projected data
proj = as.data.frame(pca$x[,1:ndim])
proj$SalePrice = scaledSalePrice

plots = lapply(1:(ndim-1), function(k){
  lapply((k+1):ndim, function(q){
    
    ggplot(data=proj, aes(x=.data[[paste0("PC", k)]], y=.data[[paste0("PC", q)]], color=.data$SalePrice)) +
      geom_point() + scale_color_viridis(option=color)+ labs(paste("PC", k, "vs PC", q)) + theme_bw()
  })
})

disp = wrap_plots(unlist(plots, recursive=FALSE))
disp

# The results of the pca made me a little sad :(, only the first component
# seems to explain something in the Sales Prices. This probably foreshadows that
# the linear models will suck

# this plots helps to understand how each variable contributes to the first ndim 
# components, and their correlations, since simlar variables tend to contribute
# to the same directions. I still need to find a way to put a number
# in the legend and x axis to identify the variables
loadings = as.data.frame(pca$rotation[,1:ndim])
names_nums = sort(rownames(loadings))
loadings = loadings[names_nums,]
nums = c("01", "02", "03", "04", "05", "06", "07", "08", "09", 10:length(rownames(loadings)))
for (i in 1:length(nums)){
  names_nums[i] = paste0(names_nums[i], "_", nums[i])
}
loadings$var = names_nums
loadings$num <- seq_along(loadings$var)
loadings = loadings %>% pivot_longer(cols=-c(var, num), names_to="PC", values_to="loading")

z = ggplot(loadings, aes(x=substr(var, nchar(var)-2, nchar(var)), y=loading, fill=factor(var))) +
  geom_bar(stat="identity", position="dodge") +
  facet_wrap(~PC, scales="free_y", ncol=1) +
  labs(title = "Variable Contributions to Principal Components", x="Variables", y="Loadings") +
  scale_fill_viridis(option=color, discrete=TRUE) +
  theme_bw()
z


# UMAP
# non linear dimensionality reduction
UMAP = umap(numdf %>% select(-SalePrice), n_components=ndim)

umap_data = as.data.frame(UMAP$layout)
umap_data$SalePrice = scaledSalePrice

plots = lapply(1:(ndim-1), function(k){
  lapply((k+1):ndim, function(q){
    
    ggplot(data=umap_data, aes(x=.data[[paste0("V", k)]], y=.data[[paste0("V", q)]], color=.data$SalePrice)) +
      geom_point() + scale_color_viridis(option=color) + labs(x=paste0("UMAP", k), y=paste0("UMAP", q)) + theme_bw()
  })
})

disp1 = wrap_plots(unlist(plots, recursive=FALSE))
disp1


# the results of the UMAP even though they are by no means great reveal something
# more than the PCA
```


```{r categorical variables}

catdf = df %>% select_if(~!is.numeric(.))
vars = colnames(catdf)
catdf$SalePrice = df$SalePrice

plots = lapply(vars, function(i){
  
  p = ggplot(data=catdf, aes_string(x=i, y="SalePrice", fill=i)) + 
    geom_boxplot() + scale_fill_viridis(option=color, discrete=TRUE) + theme_bw()
  
  plot(p)
})

# Could not fit them all in a single plot, i think we could show only the most interesting ones


# Mutual information matrix, allows to find correlations between categorical variables
mat = mutinformation(catdf %>% select(!SalePrice))
m = ggcorrplot(mat) + labs(title="Mutual Information Matrix")
m
```










